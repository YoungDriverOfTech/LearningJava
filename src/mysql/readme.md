# Mysql
## 安装Mysql
```shell
# 开启容器
docker run --name mysql -v local-dir/mysql-metadata:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:latest

# 进入容器
docker exec -it containerId sh

# 进入mysql
mysql -uroot -p
```

## 索引基础  
### 概念
- 索引： index ，在 MySQL 中也叫做“键（key）”，是一种用于快速找到记录的数据结构。在 MySQL 中，存储引擎根据索引快速定位到对应的数据行。
- 作用
  - 提高查询效率：索引可以加速查询操作，减少数据库的扫描次数，从而提高查询效率。
  - 保证数据的唯一性和完整性：索引可以用于保证表中某些列的值是唯一的，从而保证数据的唯一性和完整性。
  - 加速数据的排序和分组：索引可以用于加速数据的排序和分组操作，从而提高查询效率。
  - 减少数据库的锁竞争：索引可以减少数据库的锁竞争，从而提高数据库的并发性能。
- 注意事项：索引的建立和维护需要消耗一定的资源（索引也占用存储空间，插入、更新、删除数据时也需要变更相关索引），因此在建立索引时需要考虑索引的数量和列的选择。通常情况下，只需要建立必要的索引，避免建立过多的索引，以减少索引的维护成本和磁盘空间的占用。

### 索引的结构
MySQL常用的索引结构有：哈希索引（HASH）、B树索引（B-TREE）、B+树索引（B+TREE）

#### 哈希索引
  - Hash Index，是一种基于哈希表实现的索引类型。哈希索引将索引列的值通过哈希函数计算得到一个哈希值，然后将哈希值与数据的物理地址关联起来，从而可以快速定位到需要查询的数据。类似 Java 中的HashMap。
  - 优势：
    - 对于等值查询非常有效，可以直接根据哈希值定位到需要查询的数据，速度非常快
  - 劣势
    - 只支持等值查询，不支持范围查询
    - 索引数据并不是按照索引值顺序存储，无法用于排序
    - 不支持部分索引列匹配查找，例如在数据列（A，B）上建立哈希索引，如果查询条件只有数据列A，则无法使用索引。因为哈希索引始终使用索引列的全部内容来计算哈希值
    - 如果哈希冲突较多（不同的数据值对应的哈希值相同），索引的维护代价较高。

#### B树索引
**平衡二叉树**  
树（Tree）是一种非线性数据结构，它由若干个节点（Node）和它们之间的连接（Edge）组成。节点包含数据元素和指向其他节点的指针。  
平衡二叉搜索树（Balanced Binary Search Tree，BBST）。它满足以下性质：
- 左子树上所有节点的值均小于它的根节点的值。
- 右子树上所有节点的值均大于它的根节点的值。
- 左右子树也分别为二叉搜索树。
- 每个节点的左右子树高度差不超过1.

> 我们要查找值等于7的节点，分为以下几步：  
> 从根节点开始检索，将目标值7与节点的值10比较，7 < 10，往左子树继续查找。  
> 将7与当前节点值6比较， 7 > 6，往右子树继续查找。  
> 将7与当前节点值7比较，7 = 7，查找完成。  

![img.png](../../images/bbst.png)

**B树**  
> 虽然平衡二叉搜索树可以实现快速查找，但其不适合做为数据库的索引，为什么？
- 因为平衡二叉搜索树索引执行一次查询需要多次读写磁盘，而磁盘的读写速度相对较慢。
- 索引是存在于磁盘中的索引文件。因为索引通常是很大的，因此无法一次将全部索引加载到内存当中，因此每次只能从磁盘中读取一个磁盘页的数据到内存中。而这个磁盘的读取的速度较内存中的读取速度而言是差了好几个级别。
- 二叉树结构不能利用磁盘预读，需要多次读取磁盘。
  - 磁盘预读：磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理。
  - 局部性原理： 当一个数据被用到时，其附近的数据也通常会马上被使用。 程序运行期间所需要的数据通常比较集中。
  - 二叉树的物理实现是数组。然后由于在逻辑结构上相近的节点在物理结构上可能会差很远。每次读取的磁盘页的数据中可能有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。
  - 例如上一个例子中，10节点和6所在节点在物理结构上可能相差很远，读取10节点所在的磁盘页时，不能通过磁盘预读读取到6节点所在的磁盘页，因此读取6节点时需要再次访问磁盘。
- 二叉树每个节点只有两个分叉，当节点树较多时，树的高度会很高，意味着需要进行更多次磁盘读取（多次磁盘IO）。

---

> B树（B-Tree，有时也写作B-树，不要读成B减树），是一种多路平衡搜索树。B树的特点：

- 每个节点包含 M- 1个关键字和对应的数据，按关键字从小到大排列，K[1],K[2],…,K[M-1]，K[i] < K[i +1]
- 非叶子结点包含 M 个指向子节点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树。
- 所有叶子结点位于同一层；
![img.png](../../images/bminus.png)

> B树对应的二叉树，要查找关键字等于12的数据，二叉树需要读5次磁盘，B树只需要读3次。
![img.png](../../images/ioeg.png)


**B+树**  
> B+树（B+Tree，读作B加树），是B树的变体，也是一种多路搜索树。B+树的特点：  
- 非叶子节点包含 M 个关键字（不包含数据），按关键字从小到大排列，K[1],K[2],…,K[M]，K[i] < K[i +1]
- 非叶子结点包含 M 个指向子节点的指针：P[1], P[2], …, P[M]；其中P[i]指向关键字属于 [K[i], K[i+1]) 的子树，P[M]指向关键字大于等于K[M1]的子树。
- 叶子节点包含 M 个关键字和对应的数据，所有数据均仅在叶子节点。
- 叶子节点还包含指向下一个叶子节点的指针。
![img.png](../../images/bplus.png)


> 相较于B树，B+树的优势是什么？  
- B+树的查询效率更高。存储相同容量的数据，B+树比B树高度矮。因为B+的非叶子节点仅存储关键字不存储数据，单个非叶子节点就可以存储更多的关键字，从而减少了树的高度，意味着更少的磁盘读操作，提高了查询效率。
- B+树更适合做范围查找。因为B+树的叶子节点之间形成了一个有序链表，范围查找只需要找到左端点，再通过叶子节点之间的指针可以很快找到右端点，左右端点之间就是符合条件的数据。B树实现范围查找需要使用树的中序遍历算法，复杂度较高。而数据库中经常使用到范围查找。
- 综上，MySQL使用 B+ 树作为其索引结构。


### 索引分类

#### 按功能分
- 主键索引（Primary Key）：用于唯一标识表中的记录，索引值不允许重复，不允许为null。一张表只能有一个主键索引。
- 辅助索引（也称为二级索引，Secondary Index）：
  - 唯一索引（Unique Index）：索引值不允许重复，允许为null，一张表可以有多个唯一索引。
  - 非唯一索引：索引值允许重复，允许为null，一张表可以有多个非唯一索引。

#### 按数据列数
- 单列索引：索引只包含一个列。
- 联合索引（组合索引）：索引包含多个列。

#### 按物理存储分
- 聚簇索引（ Clustered Index ）：不是单独的一种索引类型，而是一种数据存储方式。具体的细节依赖其实现方式，InnoDB 的聚簇索引实际上是同一个结构中保存了B+树索引和数据行。聚簇索引可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。
- 非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。查询时需要先查找索引，然后再根据索引查找对应的记录。
- 每次创建非聚簇索引，都会生成一个B+书在磁盘上面，假如创建了一个(a,b,c)索引和一个d(索引)，那么就会创建两个B+树
- 每次使用非聚簇索引查找到记录以后，需要在赚到聚簇索引的那颗B+树上面去找真正的记录
- InnoDB 的主键索引是聚簇索引，辅助索引是非聚簇索引
![img.png](../../images/clusterindex.png)
![img.png](../../images/nonclusterindex.png)

> InnoDB 主键索引使用聚簇索引的优缺点分析

- 优势
  - 根据聚簇索引访问更快。聚簇索引将索引和数据保存在同一个B+树中，找到了索引也就找到了数据，不需要再进行额外查找。
- 劣势
  - 数据插入速度严重依赖插入顺序。按照主键的顺序插入是速度最快的方式，因为按照主键顺序插入可以保证都插入到最后一条记录的后面，而不按主键顺序需要在已有数据中间分配空间，增加额外工作与磁盘IO。

为保证数据按主键顺序插入，InnoDB 通常推荐使用自增id作为主键。
![img.png](../../images/prosandcons.png)

### 最左匹配原则
**最左前缀匹配原则：**
> 是指在使用联合索引进行查询时，只有在查询条件中使用了索引的最左前缀列，才能使用该索引进行查询。例如有一个联合索引 (a, b, c)，在查询时，只有在查询条件中使用了索引的最左前缀列 a 或a、b或 a、b、c时，才能使用该索引进行查询。创建联合索引(a, b, c) 相当于创建了索引 (a), (a, b), (a, b, c)。

![img.png](../../images/zuizuo.png)

> 为什么是最左前缀匹配原则？
>> 因为联合索引中，靠左的索引在B+树排序中靠前。例如有一个联合索引 (a, b, c)，比较两个索引值 (a1, b1, c1) 和 (a2, b2, c2)，先比较 a1 和 a2，若 a1 和 a2 相等再比较b1 和 b2，若 b1 和 b2 相等再比较 c1 和 c2。
> 
>> 比较的时候需要把每一列（就是每行记录）看成一个整体去比较

> 如图所示
>> 查询条件为 where a = 2 可以使用索引  
>> 查询条件为 where a = 2 and b = 3 可以使用索引  
>> 查询条件为  where b = 2 不可以使用索引  
>> 查询条件为 where a = 2 and b = 2 and c > 3 可以使用索引  
>> 查询条件为 where a > 1 and b = 1 and c = 2 可以使用索引，但使用的是索引(a)，不能使用索引(a, b, c)。这是因为使用联合索引，且最左的索引不是一个定值的话，剩下的记录需要1条1条的往后遍历去寻找，所以b和c的索引是使用不了的  

**所以，创建联合索引时经常把最常用的列放在最左**

## 索引的使用
### 创建

**非唯一索引**
```sql
ALTER TABLE `table_name` ADD INDEX `index_name` (`field1`, `field2`, ...);
```

**唯一索引**
```sql
ALTER TABLE `table_name` ADD UNIQUE INDEX `index_name` (`field1`, `field2`, ...);
```

### 删除
```sql
ALTER TABLE `table_name` DROP INDEX `index_name1`, DROP INDEX `index_name2`;
```

### 使用explain查看是否走了索引
key 表示本次查询使用的索引，rows 表示查询扫描行数。
![img.png](../../images/explain.png)

## 事务
### 定义
事务（Transaction）是指一组数据库操作，这组操作要么全部执行成功，要么全部执行失败，不会出现部分执行成功部分执行失败的情况。事务是保证数据一致性和完整性的重要机制之一。

**为什么需要事务？**  
举一个银行转账的例子，张三给李四转账1000元，对应以下操作：  
张三账户扣减 1000 元  
李四账户增加 1000 元  
要依次执行两条 SQL 语句  
```mysql
update 'bank_money' set money = money - 1000 where name = 'zhangsan';
update 'bank_money' set money = money + 1000 where name = 'lisi';
```
假如执行完第一条 SQL 之后，系统出现异常，第二条没有被执行。那么就会造成张三账户的钱减少但李四账户的钱没有相应增加，钱凭空消失了，这种情况是不能接受了。因此需要将这两条SQL放到同一事务中，用事务来保证其要么全部执行成功，要么全部执行失败（如果第一条SQL执行完后系统异常，数据库会回滚事务，撤销第一条SQL的修改）。

### 事务4大特性-ACID
在关系型数据库中，事务具有以下四个特性，通常被称为 ACID 特性：
- 原子性（Atomicity）：事务是一个原子操作，要么全部执行成功，要么全部失败回滚。如果在事务执行过程中发生了错误，所有的修改都会被撤销，回滚到事务开始前的状态，保证数据的一致性。
- 一致性（Consistency）：事务执行前后，数据库的状态应该保持一致。这意味着，在事务执行过程中，数据库的约束条件、触发器、外键等约束关系都应该得到满足，保证数据的正确性和完整性。
- 隔离性（Isolation）：多个事务并发执行时，每个事务都应该感觉不到其他事务的存在，每个事务都应该像是在独立的环境中执行。这意味着，在事务执行过程中，其他事务对该事务的修改应该被隔离起来，保证数据的正确性和一致性。
- 持久性（Durability）：事务执行成功后，对数据库的修改应该永久保存，即使系统崩溃或断电也不会丢失。这意味着，在事务执行成功后，对数据库的修改应该被持久化到磁盘中，保证数据的可靠性和持久性。  

这四个特性是事务的基本特性，也是保证数据库的数据一致性和可靠性的关键。

### 事务并发问题  
**什么是事务并发？**  
事务并发指的是多条事务同时执行。  

**事务并发会造成什么问题？**  
事务并发可能会造成以下三类问题：  
脏读  
不可重复读  
幻读  

- 脏读: 一个事务会读取到另一个事务未提交的数据  
> 事务A修改了数据但还未提交，事务B读取到了事务A修改的数据。然后事务A因为某些错误回滚了，这个时候事务B读取到的数据就是脏的，这就是脏读。
![img.png](../../images/dirtyReader.png)
- 不可重复读
> 在同一事务内，事务两次读取同一条数据的值不一样(原数据中同一条数据被修改)。
事务A读取了一条数据之后，事务B修改了这条数据并提交了事务，然后事务A再次读取这条数据，就会发现两次结果不一致。这就是不可重复读。
![img.png](../../images/unrepeatableRead.png)
- 幻读
> 事务中的同一个查询在不同的时间产生不同的行集(数据总条数新增)。
事务A使用一定的条件查询，然后事务B增加了符合条件的记录，当事务A再次查询的时候，发现两次查询的结果集不一样，好像产生了幻觉。这就是幻读。
![img.png](../../images/huanread.png)

### 事务的隔离级别
事务具有隔离性，隔离性分为不同级别，隔离级别从低到高依次为：  
- 读未提交（Read Uncommitted）：最低的隔离级别，允许一个事务读取另一个事务未提交的数据。这种隔离级别可能导致脏读、不可重复读、幻读。
- 读已提交（Read Committed）：允许一个事务读取另一个事务已提交的数据。这种隔离级别可以避免脏读问题，但可能会出现不可重复读、幻读问题。
- 可重复读（Repeatable Read）：保证在一个事务中多次读取同一数据时，结果是一致的。这种隔离级别可以避免脏读和不可重复读问题，但可能会出现幻读问题。可重复读是 MySQL 默认的事务隔离级别。
- 串行化（Serializable）：最高的隔离级别，强制事务串行执行，避免了所有并发问题。这种隔离级别可以避免脏读、不可重复读和幻读等问题，但会影响并发性能。

事务隔离级别越高，数据一致性越高，但并发性能越低。在实际应用中，需要根据具体的业务需求选择合适的事务隔离级别。

**查看事务隔离级别**  
```sql
select @@transaction_isolation;
```
**设置事务隔离级别**  
```sql
-- 设置完之后需要重新链接在能生效
set global transaction isolation level read uncommitted;
set global transaction isolation level read committed;
set global transaction isolation level repeatable read;
set global transaction isolation level serializable;
```

### 总结
![img.png](../../images/summay.png)

## 事务隔离级别实现的关键-MVCC
### 概念
Multi-Version Concurrency Control ，多版本并发控制。数据库隔离级别读已提交、可重复读 都是基于MVCC实现的。

**如何实现可重复读？**  
- 保存多个版本的数据
- 第一次读取时记录数据的版本 v1
- 第二次读取时取 v2 的数值

![img.png](../../images/mvcc.png)
> 这个方案的问题是：需要记录所有数据的版本，实现难度大。

### MVCC关键知识点
- 事务版本号：事务每次开启时，都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务开始执行的先后顺序，不能从事务ID判断事务提交的顺序，因为事务ID小的事务可能后提交。
- 隐式字段：对于InnoDB存储引擎，每一行记录都有两个隐藏列trx_id、roll_pointer，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列row_id。

![img.png](../../images/hiddenfields.png)

- Undo Log：回滚日志，用于记录数据被修改前的信息。Undo Log 的用途：事务回滚；MVCC快照读。
- 版本链：某一行数据被多次修改，对该行数据的修改会产生多个版本，然后通过回滚指针 roll_pointer连成一个链表，这个链表就称为版本链。

![img.png](../../images/undologandrollbackchain.png)

- Read View：事务执行SQL语句时，产生的读视图。
  - 每个SQL语句执行前都会得到一个Read View。
  - Read View的作用是可见性判断的，即判断当前读操作可见哪个版本的数据。
  - Read View 的几个重要属性
    - creator_trx_id: 创建当前read view的事务ID
    - m_ids: 当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List
    - min_limit_id: 表示在生成Read View时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值
    - max_limit_id: 表示生成ReadView时，系统中应该分配给下一个事务的id值

![img.png](../../images/readview.png)

- Read View 匹配：判断当前读操作可见哪个版本的数据
- Read View 匹配的基本原理：
  - 事务创建 Read View 后，希望除当前事务本身外其他事务对数据的更新对该 Read View 都不可见，否则无法实现可重复读。
  - 读取版本链时，如果读取到创建 ReadView 时还在活跃或还未创建的事务id，那么这个版本不可见，因为这个版本的提交一定在 Read View 创建之后。
  - 如果读取到的版本的事务id等于创建 Read View 的事务id，那么该版本可见。

![img.png](../../images/mvcc1.png)
![img_1.png](../../images/mvcc2.png)

- Read View 匹配规则**（注意这里的trx_id是针对所有的事务id，不是指开启本次事务的id）**：
- 如果数据事务ID trx_id < min_limit_id，表明生成该版本的事务在生成Read View前就已经提交了，所以该版本对当前读操作可见。
- 如果 trx_id>= max_limit_id ，表明生成该版本的事务在生成ReadView后才生成，所以该版本对当前读操作不可见。
- 如果 min_limit_id =< trx_id < max_limit_id，需要分3种情况讨论
  - 如果m_ids不包含trx_id，则说明你这个事务在Read View生成之前就已经提交了修改的结果，该版本对当前读操作可见。
  - 如果m_ids包含trx_id,则代表Read View生成时刻，这个事务还未提交，但是如果数据的trx_id等于creator_trx_id的话，表明数据是自己生成的，因此该版本对当前读操作可见。
  - 如果m_ids包含trx_id，并且trx_id不等于creator_trx_id，则Read View生成时，事务未提交，并且不是自己生产的，所以该版本对当前读操作不可见。

![img.png](../../images/readviewcompare.png)
![img.png](../../images/readviewmatchrules.png)

### 为什么可重复度能克服不可重复度的问题，但是读已提交不行呢？
> 读已提交，每次快照读的时候都会生成最新的read view  
> 可重复读，只有首次快照读的时候生成read view，后序的读取都使用这个旧的read view

### 《可重复读》在有些场景下能解决幻读问题，有些场景下不能，为什么？  
MySQL 里面实际上有两种读，“快照读”和“当前读”：
- 快照读（snapshot read）：是指在读取数据时，会创建一个快照来保证在事务执行期间多次读取同一数据时，结果是一致的。
- 当前读（current read）：是指在读取数据时，读取的是所有已提交的最新数据，而不是之前的快照数据。在读已提交隔离级别下，MySQL使用当前读来读取数据。
- 在《可重复读》隔离级别下，普通 select 使用的是快照读，update 使用的是当前读。  
